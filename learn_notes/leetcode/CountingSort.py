def counting_sort(arr):
    if len(arr)<=1:
        return arr
    max=arr[0]
    for i in range(1,len(arr)):
        if max<arr[i]:
            max=arr[i]
    #不用查找min,运用计数排序的时候默认最小值为0.
    C=[0]*(max+1)
    for i in arr:
        C[i]+=1
    for i in range(1,len(C)):
        C[i]+=C[i-1]
    R=[None]*len(arr)
    i=len(arr)-1
    while(i>=0):
        R[C[arr[i]]-1]=arr[i]
        C[arr[i]]-=1
        i-=1
    return R

array=[2,5,3,0,2,3,0,3]
print(counting_sort(array))


'''
计数排序：
时间复杂度：O(n),因为只需遍历
空间复杂度:
适合场合很严格：1、所有数据都是正整数，最小值为0，如果不是正整数要先转换为正整数在排序。
2、数据的最大值max不大。
3、数据规模较大。
比如有500万考试的高考总成绩，成绩最大值是900，最小值是0.
那就可以用901个桶来记录对应分数学生的个数
'''

'''
桶排序:和计数排序的区别就是桶的粒度
时间复杂度：O(n),近似计算。在每个桶里用快排，当桶的个数m接近n的时候，log(n/m)很小
适用：1、外部排序，数据存储在外部磁盘中
2、数据分布均匀，很容易均为的划分到m个桶里，并且桶之间有着天然的大小关系，桶之间不用再排序
'''


'''
基数排序：对一组手机号、单词排序（等长，如果不等长，可以通过补0等手段变为等长）
一定记住：不能从左到右的顺序排序，而是从最后一位开始比较
适用：1、需要比骄傲的数据是能够分离出独立的“位”，位之间有递进关系
2、每一位的数据不能太大，因为每一位的排序需要借助桶排序或者计数排序。
同时，位数也不能太大，不然无法实现O(n)的时间复杂度。

'''